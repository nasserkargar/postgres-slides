show database
\l
SELECT datname FROM pg_database;

CREATE DATABASE hr WITH ENCODING = 'UTF8' CONNECTION LIMIT = 100;

change active database to postgres
\c postgres

retrieve all active connections to the db database:
SELECT  *
FROM pg_stat_activity
WHERE datname = 'db';

terminate all the connections to the db database:
SELECT
    pg_terminate_backend (pid)
FROM
    pg_stat_activity
WHERE
    datname = 'db';

rename database:
ALTER DATABASE db RENAME TO newdb;


PostgreSQL copy database within the same server:
CREATE DATABASE targetdb WITH TEMPLATE sourcedb;

PostgreSQL copy database from one server to another:
pg_dump -U postgres -d sourcedb -f sourcedb.sql
CREATE DATABASE targetdb;
psql -U postgres -d targetdb -f sourcedb.sql

*** If the connection between the servers is fast and the size of the database is not big, you can use the following command:
pg_dump -C -h local -U localuser sourcedb | psql -h remote -U remoteuser targetdb

retrieve all roles in the current PostgreSQL server:
SELECT rolname FROM pg_roles;
\du

Create login roles:
CREATE ROLE alice LOGIN PASSWORD 'securePass1';
CREATE ROLE john SUPERUSER LOGIN PASSWORD 'securePass1';
CREATE ROLE dba CREATEDB LOGIN PASSWORD 'securePass1';
CREATE ROLE dev_api WITH LOGIN PASSWORD 'securePass1' VALID UNTIL '2050-01-01';
CREATE ROLE api LOGIN PASSWORD 'securePass1' CONNECTION LIMIT 1000;

* import csv file
CREATE TABLE persons (id SERIAL,first_name VARCHAR(50),last_name VARCHAR(50),dob DATE,email VARCHAR(255),PRIMARY KEY (id));
COPY persons(first_name, last_name, dob, email) FROM 'C:\sampledb\persons.csv' DELIMITER ',' CSV HEADER;

* export to csv
COPY persons TO 'C:\temp\persons_db.csv' DELIMITER ',' CSV HEADER;

* temporary table
CREATE TEMPORARY TABLE table_name(column1 datatype(size) constraint,   column1 datatype(size) constraint,   ...,   table_constraints);
CREATE TEMP TABLE mytemp(id INT);

* truncate table
TRUNCATE TABLE table_name;   (remove all data from table fast)

* add/rename/change column to table
DROP TABLE IF EXISTS customers CASCADE;
CREATE TABLE customers (id SERIAL PRIMARY KEY,customer_name VARCHAR(255) NOT NULL);
ALTER TABLE customers ADD COLUMN phone VARCHAR(25);
ALTER TABLE table_name RENAME COLUMN column_name TO new_column_name;
ALTER TABLE table_name ALTER COLUMN column_name TYPE new_data_type;
ALTER TABLE books DROP COLUMN category_id;

* table (serial datatype)
CREATE TABLE table_name(id SERIAL);

* create sequence
CREATE SEQUENCE mysequence INCREMENT 5 START 100;
SELECT nextval('mysequence');
CREATE SEQUENCE three INCREMENT -1 MINVALUE 1  MAXVALUE 3 START 3 CYCLE;  (descending order)
SELECT relname sequence_name FROM pg_class WHERE relkind = 'S'; (list all sequences in db)

* Creating a sequence associated with a table column
CREATE TABLE order_details(order_id SERIAL,item_id INT NOT NULL,item_text VARCHAR NOT NULL,price DEC(10,2) NOT NULL,PRIMARY KEY(order_id, item_id));
CREATE SEQUENCE order_item_id START 10 INCREMENT 10 MINVALUE 10 OWNED BY order_details.item_id;
INSERT INTO order_details(order_id, item_id, item_text, price) VALUES (100, nextval('order_item_id'),'DVD Player',100),(100, nextval('order_item_id'),'Android TV',550),(100, nextval('order_item_id'),'Speaker',250);
SELECT order_id,item_id,item_text,price FROM order_details;    

* create table from result of query
CREATE TABLE action_film AS SELECT film_id,title,release_year,length,rating FROM film INNER JOIN film_category USING (film_id) WHERE category_id = 1;
SELECT film_id,title,rental_rate INTO TABLE film_r FROM film WHERE rating = 'R' AND rental_duration = 5 ORDER BY title;

* rename table
ALTER TABLE table_name RENAME TO new_table_name;

* generated columns whose values are automatically calculated from other columns
CREATE TABLE contacts(
   id SERIAL PRIMARY KEY,
   first_name VARCHAR(50) NOT NULL,
   last_name VARCHAR(50) NOT NULL,
   full_name VARCHAR(101) GENERATED ALWAYS AS (first_name || ' ' || last_name) STORED,
   email VARCHAR(300) UNIQUE
);

* GENERATED AS IDENTITY constraint is the SQL standard-conforming variant of the good old SERIAL column
CREATE TABLE color (color_id INT GENERATED ALWAYS AS IDENTITY,color_name VARCHAR NOT NULL);  (only auto increment)
CREATE TABLE color (color_id INT GENERATED BY DEFAULT AS IDENTITY,color_name VARCHAR NOT NULL); (auto and manual increment)
CREATE TABLE color (color_id INT GENERATED BY DEFAULT AS IDENTITY (START WITH 10 INCREMENT BY 10),color_name VARCHAR NOT NULL); 

* table join
SELECT customer.customer_id,customer.first_name, customer.last_name, payment.amount,payment.payment_date FROM customer INNER JOIN payment ON payment.customer_id = customer.customer_id ORDER BY payment.payment_date;
SELECT film.film_id, film.title, inventory.inventory_id FROM film LEFT JOIN inventory ON inventory.film_id = film.film_id ORDER BY film.title;
SELECT film.film_id, film.title, inventory.inventory_id FROM inventory RIGHT JOIN film ON film.film_id = inventory.film_id ORDER BY film.title;
SELECT e.first_name || ' ' || e.last_name employee, m.first_name || ' ' || m.last_name manager FROM employee e INNER JOIN employee m ON m.employee_id = e.manager_id ORDER BY manager;
SELECT employee_name, department_name FROM employees e FULL OUTER JOIN departments d ON d.department_id = e.department_id;
SELECT f.title FROM film AS f ORDER BY f.title LIMIT 5;
SELECT * FROM T1 CROSS JOIN T2;
 A     |     1
 B     |     1
 A     |     2
 B     |     2
 A     |     3
 B     |     3

SELECT * FROM products NATURAL JOIN categories; (A natural join can be an inner join, left join, or right join. If you do not specify an explicit join, PostgreSQL will use the INNER JOIN by default.)

*********** filtering data
FROM customer WHERE first_name = 'Jamie' AND last_name = 'Rice';
SELECT true AND null AS result;
SELECT true OR true AS result;
FROM film ORDER BY film_id LIMIT 5;
SELECT film_id,title FROM film ORDER BY title OFFSET 5 ROWS FETCH FIRST 5 ROW ONLY; 
SELECT film_id, title FROM film WHERE film_id in (1, 2, 3);
SELECT payment_id, amount FROM payment WHERE payment_id NOT BETWEEN 17503 AND 17505 ORDER BY payment_id;
SELECT first_name, last_name FROM customer WHERE first_name LIKE '%er%' ORDER BY first_name;

The pattern _her% matches any strings that satisfy the following conditions:
    The first character can be anything.
    The following characters must be 'her'.
    There can be any number (including zero) of characters after 'her'.

Operator	Equivalent
~~	        LIKE
~~*	        ILIKE
!~~	        NOT LIKE
!~~*	        NOT ILIKE

SELECT * FROM t WHERE message LIKE '%10$%%' ESCAPE '$';   (escape character option)
FROM address WHERE address2 IS NULL;

******************************************* Querying Data
The SELECT statement has the following clauses:
    Select distinct rows using DISTINCT operator.
    Sort rows using ORDER BY clause.
    Filter rows using WHERE clause.
    Select a subset of rows from a table using LIMIT or FETCH clause.
    Group rows into groups using GROUP BY clause.
    Filter groups using HAVING clause.
    Join with other tables using joins such as INNER JOIN, LEFT JOIN, FULL OUTER JOIN, CROSS JOIN clauses.
    Perform set operations using UNION, INTERSECT, and EXCEPT.

SELECT first_name || ' ' || last_name AS column_lias,email FROM customer;
SELECT column_name AS alias_name FROM table_name;
SELECT first_name, last_name FROM customer ORDER BY first_name ASC last_name DESC;
SELECT first_name, LENGTH(first_name) len FROM customer ORDER BY len DESC;
ORDER BY sort_expresssion [ASC | DESC] [NULLS FIRST | NULLS LAST];
SELECT DISTINCT bcolor FROM colors ORDER BY bcolor;

*********************************************  Grouping Data
PostgreSQL evaluates the GROUP BY clause after the FROM and WHERE clauses and before the HAVING SELECT, DISTINCT, ORDER BY and LIMIT clauses.

SELECT customer_id, SUM (amount) FROM payment GROUP BY customer_id ORDER BY SUM (amount) DESC;
SELECT first_name || ' ' || last_name full_name, SUM (amount) amount FROM payment INNER JOIN customer USING (customer_id) GROUP BY full_name ORDER BY amount DESC;

The WHERE clause filters the rows based on a specified condition whereas the HAVING clause filter groups of rows according to a specified condition.
SELECT customer_id, SUM (amount) amount FROM payment GROUP BY customer_id HAVING SUM (amount) > 200 ORDER BY amount DESC;

********************************************* Set Operations
The UNION operator allows you to combine the result sets of two or more SELECT statements into a single result set.
SELECT select_list FROM A UNION SELECT select_list FROM B;

Like the UNION and EXCEPT operators, the PostgreSQL INTERSECT operator combines result sets of two SELECT statements into a single result set. The INTERSECT operator returns a result set containing rows available in both results sets.
SELECT select_list FROM A INTERSECT SELECT select_list FROM B;

To use the INTERSECT operator, the columns that appear in the SELECT statements must follow these rules:
    The number of columns and their order in queries must be the same.
    The data types of the columns in the queries must be compatible.

Like the UNION and INTERSECT operators, the EXCEPT operator returns rows by comparing the result sets of two or more queries.
The EXCEPT operator returns distinct rows from the first (left) query that are not in the second (right) query.
The following illustrates the syntax of the EXCEPT operator.

SELECT select_list FROM A EXCEPT SELECT select_list FROM B;
